<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FindContoursByColour" Id="{a5fbb55b-d736-4c52-9772-9c5c3bf26232}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FindContoursByColour
VAR_INPUT
			//Camera or file source
	hr: REFERENCE TO HRESULT;
	fbCamera: REFERENCE TO FB_VN_SimpleCameraControl;
	eState: REFERENCE TO ETcVnCameraState;
	
END_VAR
VAR_OUTPUT
END_VAR
VAR

//Images for realtime work
	ipImageIn: ITcVnImage;
	ipImageGrey: ITcVnImage;
	ipImageBinary: ITcVnImage;

//Region Of Interest
stRoi: TcVnRectangle_UDINT;	
	
	
// Watchdog
	hrWD 					:	HRESULT;
	tWDStop					:	DINT := 120000;	(* Stop time in us *)
	tRest 					:	DINT;
	nFunctionsMonitored		:	ULINT;
	nFractionProcessed 		:	UDINT;	
	tDuration 				:	DINT;
	
// Gaussian Filter	//

	ipImageSmoothed	:	ITcVnImage;
	ipImageSmoothedDisp	:	ITcVnDisplayableImage;
	nFilterWidth	:	UDINT	:=	51;
	nFilterHeight	:	UDINT	:=	51;
	nImageChannels: UINT;
	
//Split image channels	
pDestImages: ARRAY[0..3] OF ITcVnImage;
pDestImagesDisp:ARRAY[0..3] OF ITcVnDisplayableImage;
nArraySize: UINT;
	
//Find value range
aMaxValue:ARRAY[0..2] OF TcVnVector4_LREAL;
aMinValue:ARRAY[0..2] OF TcVnVector4_LREAL;
aPosition: TcVnPoint2_DINT;


	
//Displayable images (for ADS Image watch and TwinCAT HMI
	ipImageInDisp: ITcVnDisplayableImage;
	ipImageGreyDisp:	ITcVnDisplayableImage;
	ipImageBinaryDisp: ITcVnDisplayableImage;
	
//Colourlimits Upper/Lower RGB-values
	aColorHi	: TcVnVector4_LREAL:= [255,200,110];
	aColorLow	: TcVnVector4_LREAL:= [200,0,0];
	eVectorCompareMethod: ETcVnVectorCompareMethod:=TCVN_VCM_ELEMENTWISE;
	
//Create Structuring element for the Closing operation
ipStructuringElement: ITcVnImage;
eShape: ETcVnStructuringElementShape :=TCVN_SES_RECTANGLE;

eOperator: ETcVnMorphologicalOperator:=TCVN_MO_CLOSING;


ipContourList: 	ITCVnContainer;
	ipIterator: 	ITcVnForwardIterator;
	ipContour:		ITcVnContainer;
	fArea:	LREAL:=50000;
	fCurrentArea: LREAL;
	antalKonturer: ULINT;	
		aCenter:		TcVnPoint2_LREAL;

//Draw
	aColorRed	: TcVnVector4_LREAL:= [255,0,0,0];
	aColorBlue	: TcVnVector4_LREAL:= [0,0,255,0];	
	sArea: STRING;
	nArea: ULINT;
	n: INT;


aRectangle: TcVnRectangle_UDINT;
aRectangleUt: TcVnRectangle_UDINT;

aRotatedRectangle: TcVnRotatedRectangle;	
	
//Optionally call automatic color choice
	bDynamicColorLimits: BOOL;
	
	
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
eState:= fbCamera.GetState();

IF eState = TCVN_CS_ERROR THEN
	hr:= fbCamera.Reset();
	
ELSIF eState<TCVN_CS_ACQUIRING THEN
	hr:= fbCamera.StartAcquisition();
	
ELSIF eState= TCVN_CS_ACQUIRING THEN
	
	//Get the image from camera. Or in this case a file source
	// Step 1 - Import image
	hr:= fbCamera.GetCurrentImage(ipImageIn);
	
	IF SUCCEEDED(hr) AND ipImageIn <> 0 THEN


	
//Start watchdog to limit the time allowed for the functions below. 
hrWD := F_VN_StartRelWatchdog(tWDStop, hr);

//Filter image smooth.
	hr:= F_VN_GaussianFilter(ipImageIn, ipImageSmoothed, nFilterWidth, nFilterHeight, hr);
//hr:= F_VN_GaussianFilter(ipImageSmoothed, ipImageSmoothed, nFilterWidth, nFilterHeight, hr);



//Check color range of actual image and set limits for finding of contours (Does not work very good)
	IF bDynamicColorLimits THEN
		SetLimitsForColorRangeDynamically();
	END_IF		
		
hr:= F_VN_CopyIntoDisplayableImage(ipImageSmoothed, ipImageSmoothedDisp, hr); 

			hr:= F_VN_CheckColorRange(ipImageSmoothed, ipImageBinary, aColorLow, aColorHi, hr);		

			hr:= F_VN_CreateStructuringElement(ipStructuringElement,eShape, 25, 25, hr);		
			hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, eOperator,ipStructuringElement, hr);

			hr:= F_VN_CopyIntoDisplayableImage(ipImageBinary, ipImageBinaryDisp, hr);	

			hr:=F_VN_FindContours(ipImageBinary, ipContourList, hr);
			
			hr:= F_VN_GetNumberOfElements(ipContourList,antalKonturer,hr);
		
		hr:= F_VN_GetForwardIterator(ipContourList, ipIterator, hr);  //Create iterator
		
		//Loop through every contour with the iterator
		WHILE SUCCEEDED(hr) AND_THEN ipIterator.CheckIfEnd() <> S_OK DO
			hr:= F_VN_GetContainer(ipIterator, ipContour, hr);
			hr:= F_VN_IncrementIterator(ipIterator, hr);
	
			//Sort out only large elements
			hr:= F_VN_ContourArea(ipContour, fCurrentArea, hr);
				IF fCurrentArea > fArea THEN
				
					nArea:=LREAL_TO_ULINT(fCurrentArea);
					
					sArea:=CONCAT(CONCAT('Area: ',ULINT_TO_STRING(nArea)),' pixels');
								hr:= F_VN_DrawContours(ipContour, -1, ipImageIn, aColorRed, 3, hr);
										hr:= F_VN_ContourCenterOfMass(ipContour, aCenter, hr);
											hr:= F_VN_DrawPointExp(REAL_TO_UDINT(aCenter[0]),REAL_TO_UDINT(aCenter[1]), ipImageIn,1,aColorBlue,10,2,1,hr);
								//		hr:= F_VN_PutTextExp(sArea,ipImageIn, LREAL_TO_UDINT(aCenter[0])-400,LREAL_TO_UDINT(aCenter[1]), ETcVnFontType.TCVN_FT_HERSHEY_PLAIN, 3, aColorRed,3,TCVN_LT_8_CONNECTED,FALSE, hr);
						
				END_IF
		hr:= F_VN_CopyIntoDisplayableImage(ipImageIn, ipImageInDisp, hr); 		

				
		END_WHILE
				
//Stop watchdog to limit the time allowed for the functions above. 
hrWD := F_VN_StopWatchdog(hrWD, nFunctionsMonitored => nFunctionsMonitored, nFractionProcessed => nFractionProcessed, tRest => tRest);




END_IF
END_IF

//Anteckningar
//F_VN_SplitImageChannels
//F_VN_SetRoi
//F_VN_ResetRoi


]]></ST>
    </Implementation>
    <Method Name="SetLimitsForColorRangeDynamically" Id="{e8e2e1ec-d433-4f11-8b42-3094735696b1}">
      <Declaration><![CDATA[METHOD SetLimitsForColorRangeDynamically : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
		F_VN_SetRoi(480,410, 470, 440, ipImageSmoothed, hr);	

		//Split into three color channels
		hr:=F_VN_SplitImageChannels(ipImageSmoothed, pDestImages:= ADR(pDestImages),nArraySize:=4,hr,nImageChannels=>nImageChannels);
		IF SUCCEEDED(hr) AND pDestImages[0]<>0 THEN
			FOR n:= 0 TO 2 DO
			hr:= F_VN_CopyIntoDisplayableImage(pDestImages[n], pDestImagesDisp[n], hr); 
			END_FOR
		END_IF
		
		IF SUCCEEDED(hr) AND pDestImages[0]<>0 THEN
			FOR n:= 0 TO 2 DO
		hr:=F_VN_MaxPixelValueExp(pDestImages[n],aMaxValue[n],aPosition,ipMask:=0, eVectorCompareMethod,hr);
		hr:=F_VN_MinPixelValueExp(pDestImages[n],aMinValue[n],aPosition,ipMask:=0, eVectorCompareMethod,hr);

		
			aColorHi[n]:=aMaxValue[n][0];
			aColorLow[n]:=aMinValue[n][0];

		
			END_FOR
		END_IF
		
		hr:=F_VN_ResetRoi(ipImageSmoothed,hr);

		]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>