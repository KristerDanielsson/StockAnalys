<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FindContoursByColour" Id="{a5fbb55b-d736-4c52-9772-9c5c3bf26232}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FindContoursByColour
VAR_INPUT
			//Camera or file source
	hr: REFERENCE TO HRESULT;
	fbCamera: REFERENCE TO FB_VN_SimpleCameraControl;
	eState: REFERENCE TO ETcVnCameraState;
	
END_VAR
VAR_OUTPUT
END_VAR
VAR

//Images for realtime work
	ipImageIn: ITcVnImage;
	//ipImageGrey: ITcVnImage;
	ipImageBinary: ITcVnImage;

//Region Of Interest
stRoi: TcVnRectangle_UDINT;	
	
	
// Watchdog
	hrWD 					:	HRESULT;
	tWDStop					:	DINT := 120000;	(* Stop time in us *)
	tRest 					:	DINT;
	nFunctionsMonitored		:	ULINT;
	nFractionProcessed 		:	UDINT;	
	tDuration 				:	DINT;
	
// Gaussian Filter	//

	ipImageSmoothed	:	ITcVnImage;
	ipImageSmoothedDisp	:	ITcVnDisplayableImage;
	nFilterWidth	:	UDINT	:=	51;
	nFilterHeight	:	UDINT	:=	51;
	nImageChannels: UINT;
	
//Split image channels	
pDestImages: ARRAY[0..3] OF ITcVnImage;
pDestImagesDisp:ARRAY[0..3] OF ITcVnDisplayableImage;
nArraySize: UINT;
	
//Find value range
aMaxValue:ARRAY[0..2] OF TcVnVector4_LREAL;
aMinValue:ARRAY[0..2] OF TcVnVector4_LREAL;
aPosition: TcVnPoint2_DINT;


	
//Displayable images (for ADS Image watch and TwinCAT HMI
	ipImageInDisp: ITcVnDisplayableImage;
	//ipImageGreyDisp:	ITcVnDisplayableImage;
	ipImageBinaryDisp: ITcVnDisplayableImage;
	
//Colourlimits Upper/Lower RGB-values
	aColorHi	: TcVnVector4_LREAL:= [255,200,110];
	aColorLow	: TcVnVector4_LREAL:= [200,0,0];
	eVectorCompareMethod: ETcVnVectorCompareMethod:=TCVN_VCM_ELEMENTWISE;
	
//Create Structuring element for the Closing operation
ipStructuringElement: ITcVnImage;
eShape: ETcVnStructuringElementShape :=TCVN_SES_RECTANGLE;


eOperator: ETcVnMorphologicalOperator:=TCVN_MO_CLOSING;


ipContourList: 	ITCVnContainer;
	ipIterator: 	ITcVnForwardIterator;
	ipContour:		ITcVnContainer;
	fArea:	LREAL:=50000;
	fCurrentArea: LREAL;
	antalKonturer: ULINT;	
		aCenter:		TcVnPoint2_LREAL;

//Draw
	aColorRed	: TcVnVector4_LREAL:= [255,0,0,0];
	aColorBlue	: TcVnVector4_LREAL:= [0,0,255,0];	
	sArea: STRING;
	nArea: ULINT;
	n: INT;
	
	stEllipse: TcVnRotatedRectangle;

//HMI
aRectangle: TcVnRectangle_UDINT;
aRotatedRectangle: TcVnRotatedRectangle;

	
//Optionally call automatic color choice
	bDynamicColorLimits: BOOL;
	
	
	
	
	stImageInfo: TcVnImageInfo;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
eState:= fbCamera.GetState();

IF eState = TCVN_CS_ERROR THEN
	hr:= fbCamera.Reset();
	
ELSIF eState<TCVN_CS_ACQUIRING THEN
	hr:= fbCamera.StartAcquisition();
	
ELSIF eState= TCVN_CS_ACQUIRING THEN
	
	//Get the image from camera. Or in this case a file source
	// Step 1 - Import image
	hr:= fbCamera.GetCurrentImage(ipImageIn);
	
	IF SUCCEEDED(hr) AND ipImageIn <> 0 THEN


	
//Start watchdog to limit the time allowed for the functions below. 
hrWD := F_VN_StartRelWatchdog(tWDStop, hr);

//Filter image smooth.
	hr:= F_VN_GaussianFilter(ipImageIn, ipImageSmoothed, nFilterWidth, nFilterHeight, hr);
//hr:= F_VN_GaussianFilter(ipImageSmoothed, ipImageSmoothed, nFilterWidth, nFilterHeight, hr);
   
	hr:=F_VN_GetImageInfo(ipImageIn,stImageInfo, hr);

//Check color range of actual image and set limits for finding of contours (Does not work very well)
	IF bDynamicColorLimits THEN
		SetLimitsForColorRangeDynamically();
	END_IF

hr:= F_VN_CopyIntoDisplayableImage(ipImageSmoothed, ipImageSmoothedDisp, hr); 
			hr:= F_VN_ConvertColorSpace(ipImageSmoothed,ipImageSmoothed,TCVN_CST_RGB_TO_HSV, hr);
			hr:= F_VN_CheckColorRange(ipImageSmoothed, ipImageBinary, aColorLow, aColorHi, hr);		

			hr:= F_VN_CreateStructuringElement(ipStructuringElement,eShape, 25, 25, hr);	
	
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_EROSION,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_EROSION,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_EROSION,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, eOperator,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_DILATION,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_DILATION,ipStructuringElement, hr);
		//	hr:= F_VN_MorphologicalOperator(ipImageBinary, ipImageBinary, TCVN_MO_DILATION,ipStructuringElement, hr);

			hr:= F_VN_CopyIntoDisplayableImage(ipImageBinary, ipImageBinaryDisp, hr);	

			hr:=F_VN_FindContours(ipImageBinary, ipContourList, hr);
			
			hr:= F_VN_GetNumberOfElements(ipContourList,antalKonturer,hr);
		
		hr:= F_VN_GetForwardIterator(ipContourList, ipIterator, hr);  //Create iterator
		
		//Loop through every contour with the iterator
		WHILE SUCCEEDED(hr) AND_THEN ipIterator.CheckIfEnd() <> S_OK DO
			hr:= F_VN_GetContainer(ipIterator, ipContour, hr);
			hr:= F_VN_IncrementIterator(ipIterator, hr);
	
			//Sort out only large elements
			hr:= F_VN_ContourArea(ipContour, fCurrentArea, hr);
				IF fCurrentArea > fArea THEN
				
					nArea:=LREAL_TO_ULINT(fCurrentArea);
					
					sArea:=CONCAT(CONCAT('Area: ',ULINT_TO_STRING(nArea)),' pixels');
								hr:= F_VN_DrawContours(ipContour, -1, ipImageIn, aColorRed, 3, hr);
										hr:= F_VN_ContourCenterOfMass(ipContour, aCenter, hr);
											hr:= F_VN_DrawPointExp(REAL_TO_UDINT(aCenter[0]),REAL_TO_UDINT(aCenter[1]), ipImageIn,1,aColorBlue,10,2,1,hr);
								hr:= F_VN_PutTextExp(sArea,ipImageIn, LREAL_TO_UDINT(aCenter[0])-400,LREAL_TO_UDINT(aCenter[1]), ETcVnFontType.TCVN_FT_HERSHEY_PLAIN, 3, aColorRed,3,TCVN_LT_8_CONNECTED,FALSE, hr);
					hr:=F_VN_FitEllipse(ipContour,stEllipse, hr);	
					hr:=F_VN_DrawEllipse( stEllipse,ipImageIn, aColorBlue, 3, hr);

				END_IF
	

				
		END_WHILE
		
				hr:= F_VN_CopyIntoDisplayableImage(ipImageIn, ipImageInDisp, hr); 	
				
//Stop watchdog to limit the time allowed for the functions above. 
hrWD := F_VN_StopWatchdog(hrWD, nFunctionsMonitored => nFunctionsMonitored, nFractionProcessed => nFractionProcessed, tRest => tRest);




END_IF
END_IF

//Anteckningar
//F_VN_SplitImageChannels
//F_VN_SetRoi
//F_VN_ResetRoi


]]></ST>
    </Implementation>
    <Method Name="SetLimitsForColorRangeDynamically" Id="{e8e2e1ec-d433-4f11-8b42-3094735696b1}">
      <Declaration><![CDATA[METHOD SetLimitsForColorRangeDynamically : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
		F_VN_SetRoi(480,410, 470, 440, ipImageSmoothed, hr);	

		//Split into three color channels
		hr:=F_VN_SplitImageChannels(ipImageSmoothed, pDestImages:= ADR(pDestImages),nArraySize:=4,hr,nImageChannels=>nImageChannels);
		IF SUCCEEDED(hr) AND pDestImages[0]<>0 THEN
			FOR n:= 0 TO 2 DO
			hr:= F_VN_CopyIntoDisplayableImage(pDestImages[n], pDestImagesDisp[n], hr); 
			END_FOR
		END_IF
		
		IF SUCCEEDED(hr) AND pDestImages[0]<>0 THEN
			FOR n:= 0 TO 2 DO
		hr:=F_VN_MaxPixelValueExp(pDestImages[n],aMaxValue[n],aPosition,ipMask:=0, eVectorCompareMethod,hr);
		hr:=F_VN_MinPixelValueExp(pDestImages[n],aMinValue[n],aPosition,ipMask:=0, eVectorCompareMethod,hr);

		
			aColorHi[n]:=aMaxValue[n][0];
			aColorLow[n]:=aMinValue[n][0];

		
			END_FOR
		END_IF
		
		hr:=F_VN_ResetRoi(ipImageSmoothed,hr);

		]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FindContoursByColour">
      <LineId Id="3" Count="25" />
      <LineId Id="196" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="29" Count="44" />
      <LineId Id="75" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FindContoursByColour.SetLimitsForColorRangeDynamically">
      <LineId Id="3" Count="25" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>